"""
Infrastructure for label validation timeline API endpoint.

This module creates a Lambda function that serves the cached timeline
data from S3. The cache is generated by the label_validation_timeline_cache
Lambda.
"""

import json
import os
from typing import Optional

import pulumi
import pulumi_aws as aws
from pulumi import AssetArchive, FileArchive, Input, Output

# Reference the directory containing index.py
HANDLER_DIR = os.path.join(os.path.dirname(__file__), "handler")
# Get the route name from the directory name
ROUTE_NAME = os.path.basename(os.path.dirname(__file__))

# Get stack configuration
stack = pulumi.get_stack()

# Module-level variable to hold the Lambda function
# This will be set when create_label_validation_timeline_lambda is called
label_validation_timeline_lambda: Optional[aws.lambda_.Function] = None


def create_label_validation_timeline_lambda(
    cache_bucket_name: Input[str],
) -> aws.lambda_.Function:
    """Create the label validation timeline API Lambda function.

    This function should only be called after the cache bucket exists.

    Args:
        cache_bucket_name: The S3 bucket name containing the timeline cache

    Returns:
        The created Lambda function
    """
    global label_validation_timeline_lambda

    # Create IAM role for the Lambda function
    lambda_role = aws.iam.Role(
        f"api_{ROUTE_NAME}_lambda_role",
        assume_role_policy="""{
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Action": "sts:AssumeRole",
                    "Principal": {
                        "Service": "lambda.amazonaws.com"
                    },
                    "Effect": "Allow",
                    "Sid": ""
                }
            ]
        }""",
    )

    # S3 read policy for cache bucket
    s3_policy = aws.iam.RolePolicy(
        f"api_{ROUTE_NAME}_s3_policy",
        role=lambda_role.id,
        policy=Output.from_input(cache_bucket_name).apply(
            lambda bucket: json.dumps(
                {
                    "Version": "2012-10-17",
                    "Statement": [
                        {
                            "Effect": "Allow",
                            "Action": ["s3:GetObject", "s3:ListBucket"],
                            "Resource": [
                                f"arn:aws:s3:::{bucket}/*",
                                f"arn:aws:s3:::{bucket}",
                            ],
                        }
                    ],
                }
            )
        ),
    )

    # Attach basic execution role
    aws.iam.RolePolicyAttachment(
        f"api_{ROUTE_NAME}_basic_execution",
        role=lambda_role.name,
        policy_arn="arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole",
    )

    # Create the Lambda function
    label_validation_timeline_lambda = aws.lambda_.Function(
        f"api_{ROUTE_NAME}_GET_lambda",
        runtime="python3.12",
        architectures=["arm64"],
        role=lambda_role.arn,
        code=AssetArchive(
            {
                ".": FileArchive(HANDLER_DIR),
            }
        ),
        handler="index.handler",
        environment=Output.from_input(cache_bucket_name).apply(
            lambda bucket: aws.lambda_.FunctionEnvironmentArgs(
                variables={
                    "S3_CACHE_BUCKET": bucket,
                }
            )
        ),
        memory_size=256,
        timeout=30,  # Fast since it just reads from S3
        tags={"environment": stack},
    )

    # CloudWatch log group
    aws.cloudwatch.LogGroup(
        f"api_{ROUTE_NAME}_log_group",
        name=label_validation_timeline_lambda.name.apply(
            lambda fn: f"/aws/lambda/{fn}"
        ),
        retention_in_days=7,
    )

    # Export Lambda details
    pulumi.export(
        f"{ROUTE_NAME}_lambda_arn", label_validation_timeline_lambda.arn
    )
    pulumi.export(
        f"{ROUTE_NAME}_lambda_name", label_validation_timeline_lambda.name
    )

    return label_validation_timeline_lambda
