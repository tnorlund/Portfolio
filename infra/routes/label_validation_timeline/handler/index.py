"""
Lambda handler for serving label validation timeline cache.

This Lambda function serves the cached label validation timeline from S3.
The cache is generated by the label_validation_timeline_cache Lambda.
"""

import json
import logging
import os
from datetime import datetime, timezone

import boto3
from botocore.exceptions import ClientError

logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Environment variables
S3_CACHE_BUCKET = os.environ.get("S3_CACHE_BUCKET")
S3_CACHE_KEY = "label_validation_timeline.json"

if not S3_CACHE_BUCKET:
    logger.error("S3_CACHE_BUCKET environment variable not set")

# Initialize S3 client
s3_client = boto3.client("s3")


def handler(event, _context):
    """Handle API Gateway requests for label validation timeline.

    Returns the cached timeline data from S3.

    Args:
        event: API Gateway event containing HTTP request details
        _context: Lambda context (unused but required by Lambda)

    Returns:
        dict: HTTP response with cached timeline data or error
    """
    logger.info("Received event: %s", event)

    # Handle API Gateway v2 event format
    try:
        http_method = event["requestContext"]["http"]["method"].upper()
    except (KeyError, TypeError) as e:
        logger.error("Invalid event structure: %s", e)
        return {
            "statusCode": 500,
            "body": json.dumps({"error": "Invalid event structure"}),
            "headers": {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*",
            },
        }

    if http_method != "GET":
        return {
            "statusCode": 405,
            "body": json.dumps({"error": f"Method {http_method} not allowed"}),
            "headers": {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*",
            },
        }

    if not S3_CACHE_BUCKET:
        logger.error("S3_CACHE_BUCKET environment variable not set")
        return {
            "statusCode": 500,
            "body": json.dumps(
                {"error": "Configuration error: S3_CACHE_BUCKET not set"}
            ),
            "headers": {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*",
            },
        }

    try:
        # Fetch cache from S3
        logger.info(
            "Fetching cache from s3://%s/%s", S3_CACHE_BUCKET, S3_CACHE_KEY
        )
        response = s3_client.get_object(
            Bucket=S3_CACHE_BUCKET, Key=S3_CACHE_KEY
        )
        cache_data = json.loads(response["Body"].read().decode("utf-8"))

        logger.info(
            "Returning timeline with %d keyframes",
            len(cache_data.get("keyframes", [])),
        )

        return {
            "statusCode": 200,
            "body": json.dumps(cache_data),
            "headers": {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*",
            },
        }

    except ClientError as e:
        error_code = e.response.get("Error", {}).get("Code", "Unknown")
        if error_code == "NoSuchKey":
            logger.warning(
                "Cache not found at s3://%s/%s", S3_CACHE_BUCKET, S3_CACHE_KEY
            )
            return {
                "statusCode": 404,
                "body": json.dumps(
                    {
                        "error": "Cache not found",
                        "message": "Timeline cache has not been generated yet. "
                        "Invoke the cache generator Lambda to create it.",
                    }
                ),
                "headers": {
                    "Content-Type": "application/json",
                    "Access-Control-Allow-Origin": "*",
                },
            }
        logger.error("S3 error: %s", e, exc_info=True)
        return {
            "statusCode": 500,
            "body": json.dumps({"error": f"S3 error: {error_code}"}),
            "headers": {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*",
            },
        }

    except Exception as e:
        logger.error("Unexpected error: %s", e, exc_info=True)
        return {
            "statusCode": 500,
            "body": json.dumps({"error": str(e)}),
            "headers": {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*",
            },
        }
