# CI Test Profiling and Optimization Guide

This guide explains how to use the CI optimization tools to profile and optimize test execution in your CI pipeline.

## Overview

The CI optimization suite includes:

1. **CI Profiler** (`scripts/ci_profiler.py`) - Captures test execution metrics
2. **Smart Test Runner** (`scripts/smart_test_runner.py`) - Intelligent test selection
3. **CI Cache Optimizer** (`scripts/optimize_ci_cache.sh`) - Dependency and build caching
4. **Test Distribution Optimizer** (`scripts/optimize_test_distribution.py`) - Optimal test parallelization
5. **CI Performance Monitor** (`.github/workflows/ci-performance.yml`) - Automated monitoring

## Quick Start

### 1. Profile Your Current CI Performance

First, collect baseline metrics:

```bash
# Profile CI execution
python scripts/ci_profiler.py --collect --job-name "main-ci"

# Analyze recent performance (last 7 days)
python scripts/ci_profiler.py --analyze --days 7

# Generate performance report
python scripts/ci_profiler.py --report --format text
```

### 2. Optimize Test Selection

Use smart test selection to reduce test execution time:

```bash
# Analyze which tests need to run based on changes
python scripts/smart_test_runner.py receipt_dynamo tests/integration --analyze

# Run only affected tests
python scripts/smart_test_runner.py receipt_dynamo tests/integration --dry-run

# Execute optimized test run
python scripts/smart_test_runner.py receipt_dynamo tests/integration
```

### 3. Optimize Dependency Caching

Set up intelligent caching for faster builds:

```bash
# Setup cache structure
./scripts/optimize_ci_cache.sh --setup

# Optimize Python dependencies
./scripts/optimize_ci_cache.sh --python-deps receipt_dynamo

# Optimize Node.js dependencies
./scripts/optimize_ci_cache.sh --node-deps

# Analyze cache performance
./scripts/optimize_ci_cache.sh --analyze
```

### 4. Optimize Test Distribution

Balance test execution across parallel jobs:

```bash
# Profile test execution times
python scripts/optimize_test_distribution.py receipt_dynamo --profile

# Analyze current distribution
python scripts/optimize_test_distribution.py receipt_dynamo --analyze

# Generate optimized distribution
python scripts/optimize_test_distribution.py receipt_dynamo --optimize --groups 4

# Generate GitHub Actions matrix
python scripts/optimize_test_distribution.py receipt_dynamo --generate-matrix --output optimized_matrix.json
```

## Integration with GitHub Actions

### Enhanced Main Workflow

Here's an example of how to integrate optimization tools into your main workflow:

```yaml
# .github/workflows/main-optimized.yml
name: Optimized CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  # Stage 1: Fast checks with caching
  fast-checks:
    name: Fast Checks
    runs-on: [self-hosted, macOS, ARM64]
    steps:
      - uses: actions/checkout@v4
      
      # Setup intelligent caching
      - name: Setup CI cache
        run: ./scripts/optimize_ci_cache.sh --setup
      
      # Optimize Python dependencies
      - name: Cache Python dependencies
        run: ./scripts/optimize_ci_cache.sh --python-deps receipt_dynamo
      
      # Smart test selection
      - name: Analyze test requirements
        run: |
          python scripts/smart_test_runner.py receipt_dynamo tests/unit --analyze > test_analysis.json
      
      - name: Upload test analysis
        uses: actions/upload-artifact@v4
        with:
          name: test-analysis
          path: test_analysis.json

  # Stage 2: Optimized parallel tests
  test-python:
    name: Python Tests (${{ matrix.test_group }})
    needs: fast-checks
    runs-on: [self-hosted, macOS, ARM64]
    strategy:
      matrix:
        # This matrix is generated by optimize_test_distribution.py
        include:
          - package: receipt_dynamo
            test_group: group-1
            test_path: tests/integration/test__receipt_word_label.py tests/integration/test__receipt.py
          - package: receipt_dynamo
            test_group: group-2
            test_path: tests/integration/test__receipt_field.py tests/integration/test__receipt_chatgpt_validation.py
    steps:
      - uses: actions/checkout@v4
      
      # Restore optimized cache
      - name: Restore Python cache
        run: ./scripts/optimize_ci_cache.sh --python-deps ${{ matrix.package }}
      
      # Profile test execution
      - name: Profile test execution
        run: |
          python scripts/ci_profiler.py --collect --job-name "${{ matrix.package }}-${{ matrix.test_group }}"
      
      # Run optimized tests
      - name: Run smart tests
        run: |
          python scripts/smart_test_runner.py ${{ matrix.package }} "${{ matrix.test_path }}"
      
      # Upload metrics
      - name: Upload CI metrics
        uses: actions/upload-artifact@v4
        with:
          name: ci-metrics-${{ matrix.test_group }}
          path: ci-metrics/

  # Stage 3: Performance analysis
  performance-analysis:
    name: Performance Analysis
    needs: test-python
    if: always()
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      # Download all metrics
      - name: Download CI metrics
        uses: actions/download-artifact@v4
        with:
          pattern: ci-metrics-*
          path: ci-metrics/
          merge-multiple: true
      
      # Analyze performance
      - name: Analyze CI performance
        run: |
          python scripts/ci_profiler.py --analyze --days 1 --format json > analysis.json
          python scripts/generate_ci_recommendations.py analysis.json > recommendations.md
      
      # Upload analysis
      - name: Upload performance analysis
        uses: actions/upload-artifact@v4
        with:
          name: performance-analysis
          path: |
            analysis.json
            recommendations.md
```

### PR Checks Optimization

```yaml
# .github/workflows/pr-checks-optimized.yml
name: Optimized PR Checks

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  smart-tests:
    name: Smart Test Selection
    runs-on: [self-hosted, macOS, ARM64]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for change detection
      
      # Smart test selection based on changes
      - name: Analyze changed files
        run: |
          python scripts/smart_test_runner.py receipt_dynamo tests --analyze --dry-run
      
      # Cache optimization
      - name: Optimize dependencies
        run: |
          ./scripts/optimize_ci_cache.sh --python-deps receipt_dynamo
      
      # Run only affected tests
      - name: Run affected tests
        run: |
          python scripts/smart_test_runner.py receipt_dynamo tests
```

## Performance Monitoring Dashboard

The CI Performance Monitor workflow runs automatically and provides:

### Automated Monitoring
- Daily performance analysis
- Trend detection
- Bottleneck identification
- Cost optimization recommendations

### Performance Metrics
- Job duration trends
- Success rate tracking
- Cache hit rates
- Resource utilization

### Alerts and Recommendations
- Automatic issue creation for performance regressions
- Optimization suggestions
- Cost impact analysis

## Best Practices

### 1. Cache Strategy
- Use content-based cache keys for better hit rates
- Implement cache cleanup policies
- Monitor cache effectiveness regularly

### 2. Test Distribution
- Rebalance test groups monthly
- Profile new tests as they're added
- Consider test complexity, not just count

### 3. Smart Test Selection
- Maintain accurate dependency graphs
- Use historical data for flaky test detection
- Implement test impact analysis

### 4. Monitoring
- Set up performance alerts
- Review trends weekly
- Track key metrics consistently

## Optimization Workflow

### Weekly Optimization Process

1. **Monday**: Review performance dashboard
2. **Tuesday**: Analyze cache hit rates and optimize if needed
3. **Wednesday**: Profile any new or slow tests
4. **Thursday**: Rebalance test distribution if needed
5. **Friday**: Review and implement optimization recommendations

### Monthly Deep Dive

1. Comprehensive performance analysis
2. Test distribution rebalancing
3. Cache strategy review
4. Tool effectiveness assessment
5. Cost optimization review

## Troubleshooting

### Common Issues

**Slow Test Execution**
```bash
# Profile specific tests
python scripts/optimize_test_distribution.py package_name --profile

# Identify bottlenecks
python scripts/ci_profiler.py --analyze --format json | jq '.jobs[].bottlenecks'
```

**Poor Cache Hit Rates**
```bash
# Analyze cache performance
./scripts/optimize_ci_cache.sh --analyze

# Check cache key generation
./scripts/optimize_ci_cache.sh --cleanup 7  # Clean old cache
```

**Unbalanced Test Distribution**
```bash
# Analyze current balance
python scripts/optimize_test_distribution.py package_name --analyze

# Generate new optimized distribution
python scripts/optimize_test_distribution.py package_name --optimize --groups 4
```

## Expected Results

### Performance Improvements
- **Test Execution**: 40-60% faster through smart selection
- **Dependency Installation**: 70-80% faster with caching
- **Build Times**: 50-70% faster with optimized distribution
- **Overall CI Time**: 40-50% reduction

### Cost Savings
- **GitHub Actions Minutes**: 50-70% reduction
- **Self-hosted Runner Efficiency**: 30-40% improvement
- **Infrastructure Costs**: Significant reduction with optimization

### Developer Experience
- **Faster Feedback**: Quicker PR validation
- **Reliable Builds**: Reduced flaky test impact
- **Better Visibility**: Clear performance metrics
- **Proactive Optimization**: Automated recommendations

## Integration Timeline

### Week 1: Setup and Profiling
- Deploy CI profiler
- Collect baseline metrics
- Set up caching infrastructure

### Week 2: Smart Test Selection
- Implement smart test runner
- Optimize test selection logic
- Validate change detection

### Week 3: Distribution Optimization
- Profile test execution times
- Rebalance test groups
- Update GitHub Actions matrices

### Week 4: Monitoring and Tuning
- Deploy performance monitoring
- Set up alerts and dashboards
- Fine-tune optimizations

This comprehensive approach to CI optimization will significantly improve your development workflow while reducing costs and increasing reliability.